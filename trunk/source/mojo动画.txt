anim : function(){//自定义动画
			var args = arguments,len = args.length,obj = args[0],
				d,fn,type,ease,
				options,arr,
				tids = [];//存放计时器id
				
			if(len == 2 && typeof args[1] == "object"){//参数为对象的形式
				    options = args[1];
					d = options.dur ? options.dur : 200;//动画时间
					fn = options.fn ? options.fn : null;//完成回调函数
					type = (options.type)[0] ? (options.type)[0] : "linear";//动画类型
					ease = (options.type)[1] ? (options.type)[1] : "easeIn";//缓冲类型
			}else{//多参数形式
				d = args[1] ? args[1] : 200;
				fn = args[2] ? args[2] : null;
				type = args[3] ? args[3] : "linear";
				ease = args[4] ? args[4] : "easeIn";
			}
			
			options = [];//依次装入:属性名,符号,值,单位
			for(var prop in obj){//解析属性值
				
				options.push(prop);
				prop = prop.replace(/opacity/,"");
				arr = obj[prop].match(/((-=)?|(\+=)?)(-?\d+)(\D*)/);
				options.push(arr[2] || arr[3]);
				options.push(arr[4]);
				options.push(arr[5] || "px");				
			}
			arr = this;//传递给回调函数作为this的值
			
			jo.iteratorElems(this.s,function(e){
				tids.push(jo.parseAnim(e,options,d,type,ease,fn,arr));
			});
			
			if(!this.tids)
				this.tids = [];//存档动画计时器id
			this.tids.push(tids);
			
			return this;
		}




parseAnim : function(e,ops,d,type,ease,fn,ths){//配置anim
			var b,c,t,j,//初始值,变化值,当前时间
				len = ops.length,
				n = len/4,//属性的个数
		    	f = 10,//每次变化值
		    	step = [];//属性值变化数组
		    	
		    for(var i=0; i<len; i+=4){
				b = parseInt(this.getStyle(ops[i],e));
				if(!b) b = 0;//设置初始值
				
				switch(ops[i+1]){//判断符号,设置变化量
					case "+=" : c = ops[i+2]*1;
						break;
					case "-=" : c = ops[i+2]*1 - ops[i+2]*2;
						break;
					default : c = ops[i+2]*1 - b;
				}
				t = 0;
				step[i/4] = ops[i];//压入属性值
				j = i;
				while(t <= d){
					//调用了tween算法,ops[j+3]是单位
					step[n+j/4] = Math.ceil(tween[type][ease](t,b,c,d)) + ops[i+3];
					j += 4*n;
					t += f;
				}
			}
			return this.timer(step,fn,e,ths,n);
		},
		timer : function(step,fn,e,ths,n){//启动定时器
			var i = n,j = step.length,k,
				tid = setInterval(function(){
					if(i<j)
						for(k=0; k<n; k++)
							jo.setSty(step[k],e,step[i+k]);
					else{
						clearInterval(tid);
						if(fn)
							fn.call(ths,e);
					}
					i += n;
			},10);
			return tid;
		}





timer : function(step,fn,e,ths,n){//启动定时器
			var i = n,arr = [],str = "",sty = e.style,tid;
				for(var j=step.length; i<j; i+=n){
					for (var k = 0; k < n; k++) {
						str = this.getCssText(step,k,i,str,e);
					}
					arr.push(str);
					str = "";
				}
				i = 0;
				n = arr.length;
				tid = setInterval(function(){
					if (i < n) {
						sty.cssText = arr[i];
					}
					else {
						clearInterval(tid);
						if (fn) 
							fn.call(ths,e);
					}
					i++;
			},10); 
			return tid;
		}

		getCssText : function(step,k,i,str,e){//cssText
			switch(step[k]){
				case "opacity" : e.filters ? 
								 str += "filter:alpha(opacity=" + step[i + k] + ");" :
								 str += step[k] + ":" + (step[i + k]/100) + ";";
				default : str += step[k] + ":" + step[i + k] + ";";
			}
			return str;
		},


